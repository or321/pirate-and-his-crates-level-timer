// Generated by Haxe 3.4.7
(function () { "use strict";
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var BSHead = function() {
	this.bitIndex = 0;
	this.blockIndex = 0;
};
BSHead.__name__ = true;
BSHead.prototype = {
	read: function(data) {
		if(data.length <= this.blockIndex) {
			return haxe_ds_Option.None;
		} else {
			return haxe_ds_Option.Some((data[this.blockIndex] >> this.bitIndex & 1) == 1);
		}
	}
	,write: function(data,value) {
		while(data.length <= this.blockIndex) data.push(0);
		if(value) {
			data[this.blockIndex] |= 1 << this.bitIndex;
		}
	}
	,increment: function() {
		this.bitIndex += 1;
		if(this.bitIndex > 5) {
			this.bitIndex = 0;
			this.blockIndex += 1;
		}
	}
};
var BSWriter = function() {
	this.head = new BSHead();
	this.data = [];
};
BSWriter.__name__ = true;
BSWriter.prototype = {
	toString: function() {
		var str = "";
		var _g = 0;
		var _g1 = this.data;
		while(_g < _g1.length) {
			var digit = _g1[_g];
			++_g;
			str += haxe_crypto_Base64.CHARS.charAt(digit);
		}
		return str;
	}
	,writeInt: function(value,bits) {
		var _g1 = 0;
		var _g = bits;
		while(_g1 < _g) {
			var i = _g1++;
			this.write([(value >> i & 1) == 1]);
		}
	}
	,write: function(values) {
		var _g = 0;
		while(_g < values.length) {
			var value = values[_g];
			++_g;
			this.head.write(this.data,value);
			this.head.increment();
		}
	}
};
var BSReader = function(encoded) {
	this.head = new BSHead();
	this.data = [];
	var _g1 = 0;
	var _g = encoded.length;
	while(_g1 < _g) {
		var i = _g1++;
		this.data.push(this.charToInt(encoded.charAt(i)));
	}
};
BSReader.__name__ = true;
BSReader.prototype = {
	charToInt: function($char) {
		var _g = 0;
		while(_g < 64) {
			var i = _g++;
			if(haxe_crypto_Base64.CHARS.charAt(i) == $char) {
				return i;
			}
		}
		throw new js__$Boot_HaxeError("base64 out of bounds");
	}
	,read: function(length) {
		var bits = [];
		var _g1 = 0;
		var _g = length;
		while(_g1 < _g) {
			var i = _g1++;
			var _g2 = this.head.read(this.data);
			switch(_g2[1]) {
			case 0:
				var bit = _g2[2];
				bits.push(bit);
				break;
			case 1:
				return haxe_ds_Option.None;
			}
			this.head.increment();
		}
		return haxe_ds_Option.Some(bits);
	}
	,readInt: function(length) {
		var _g = this.read(length);
		switch(_g[1]) {
		case 0:
			var bits = _g[2];
			var sum = 0;
			var _g1 = 0;
			var _g2 = length;
			while(_g1 < _g2) {
				var i = _g1++;
				sum += (bits[i] ? 1 : 0) << i;
			}
			return haxe_ds_Option.Some(sum);
		case 1:
			return haxe_ds_Option.None;
		}
	}
};
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.__name__ = true;
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw new js__$Boot_HaxeError("EReg::matched");
		}
	}
};
var PlayControl = function() {
	this.silent = false;
	this.speed = 0;
	this.paused = false;
	this.frame = 0;
};
PlayControl.__name__ = true;
PlayControl.prototype = {
	pause: function() {
		this.paused = true;
		this.speed = 0;
	}
};
var Engine = function() {
	this.fakeTime = 0;
	this.pausedCallback = haxe_ds_Option.None;
	this.fullgameLevelCounter = 0;
	this.fullgameVideo = null;
	this.recording = new VideoRecorder([false,false,false,false]);
	this.playback = haxe_ds_Option.None;
	this.control = new PlayControl();
	this.initialDirections = [false,false,false,false];
	this.frameLength = 16.66666666;
	this.frameLengthDecimalPlaces = 8;
	var _gthis = this;
	this._requestAnimationFrame = ($_=window,$bind($_,$_.requestAnimationFrame));
	this._now = ($_=window.performance,$bind($_,$_.now));
	window.requestAnimationFrame = $bind(this,this.requestAnimationFrame);
	window.performance.now = function() {
		return _gthis.fakeTime;
	};
	this.fakeTime = this._now();
	window.coffee = { };
	window.coffee._onScene = $bind(this,this.onScene);
	window.coffee._keyup = $bind(this,this.keyup);
	window.coffee._keydown = $bind(this,this.keydown);
	window.coffee.load = function(string,slot) {
		if(slot == null || slot > 9 || slot < 0) {
			slot = 0;
		}
		_gthis.slots[slot] = new Video(string);
	};
	window.coffee.loadFullGame = function(strings) {
		_gthis.fullgameVideo = strings.map(function(videoString) {
			return new Video(videoString);
		});
		_gthis.control.speed = 1;
		_gthis.control.paused = false;
		_gthis.triggerPausedCallback();
	};
	window.coffee.clearFullGame = function(string1) {
		_gthis.fullgameVideo = null;
	};
	window.coffee.initialLeft = function(pressed) {
		_gthis.initialDirections[0] = pressed;
	};
	window.coffee.initialRight = function(pressed1) {
		_gthis.initialDirections[1] = pressed1;
	};
	window.coffee.initialUp = function(pressed2) {
		_gthis.initialDirections[2] = pressed2;
	};
	window.coffee.initialDown = function(pressed3) {
		_gthis.initialDirections[3] = pressed3;
	};
	this.slots = [];
	var _g = 0;
	while(_g < 10) {
		var i = _g++;
		this.slots.push(new Video());
	}
	this.control.speed = 1;
};
Engine.__name__ = true;
Engine.prototype = {
	wrapCallback: function(callback) {
		var _gthis = this;
		return function() {
			var _g = _gthis.playback;
			switch(_g[1]) {
			case 0:
				var player = _g[2];
				var _g1 = 0;
				var _g11 = player.getActions(_gthis.control.frame);
				while(_g1 < _g11.length) {
					var action = _g11[_g1];
					++_g1;
					_gthis.sendGameInput(action.code,action.pressed);
				}
				if(_gthis.control.frame + 1 >= player.video.pauseFrame) {
					if(_gthis.fullgameVideo == null) {
						_gthis.control.pause();
						console.log("[PAUSE ] @ " + (_gthis.control.frame + 1));
						_gthis.control.silent = false;
					} else if(_gthis.fullgameLevelCounter >= 1 && _gthis.fullgameLevelCounter <= 15) {
						_gthis.initialDirections = _gthis.fullgameVideo[_gthis.fullgameLevelCounter - 1].initialDirections.slice();
						_gthis.control.frame = 0;
						_gthis.primeControls(true);
					}
					_gthis.playback = haxe_ds_Option.None;
				}
				break;
			case 1:
				break;
			}
			_gthis.fakeTime += _gthis.frameLength;
			callback(_gthis.fakeTime);
			_gthis.control.frame += 1;
		};
	}
	,requestAnimationFrame: function(callback) {
		var wrappedCallback = this.wrapCallback(callback);
		if(!this.control.paused) {
			var _g = this.control.speed;
			switch(_g) {
			case 0:
				window.setTimeout(wrappedCallback,100);
				break;
			case 1:
				this._requestAnimationFrame(wrappedCallback);
				break;
			default:
				window.setTimeout(wrappedCallback,0);
			}
		} else {
			this.pausedCallback = haxe_ds_Option.Some(wrappedCallback);
		}
	}
	,triggerPausedCallback: function() {
		var _g = this.pausedCallback;
		switch(_g[1]) {
		case 0:
			var cb = _g[2];
			this.pausedCallback = haxe_ds_Option.None;
			cb();
			break;
		case 1:
			break;
		}
	}
	,keyup: function(callback) {
		var _gthis = this;
		this.keyupHandler = callback;
		window.onkeyup = function(key) {
			_gthis.onKey(key,false);
		};
	}
	,keydown: function(callback) {
		var _gthis = this;
		this.keydownHandler = callback;
		window.onkeydown = function(key) {
			_gthis.onKey(key,true);
		};
	}
	,onKey: function(event,pressed) {
		if(!Util.isSome(this.playback)) {
			var suppress = [83,65,68,82,90];
			if(suppress.indexOf(event.keyCode) == -1) {
				this.sendGameInput(event.keyCode,pressed);
			}
		}
		if(pressed && this.fullgameVideo == null) {
			var _g = KeyBindings.fromKeyCode(event.keyCode);
			if(_g[1] == 0) {
				var input = _g[2];
				if(this.handleInterfaceInput(input,event.ctrlKey,event.altKey)) {
					event.preventDefault();
				}
			}
		}
	}
	,sendGameInput: function(keyCode,pressed) {
		this.recording.recordKey(this.control.frame,keyCode,pressed,this.control.silent);
		var event = { which : keyCode, key : KeyCodes.toKey(keyCode), preventDefault : function() {
		}, stopPropagation : function() {
		}};
		if(pressed) {
			this.keydownHandler(event);
		} else {
			this.keyupHandler(event);
		}
	}
	,primeControls: function(buffer) {
		var _g = 0;
		var _g1 = Video.keyCodes;
		while(_g < _g1.length) {
			var code = _g1[_g];
			++_g;
			this.sendGameInput(code,false);
		}
		var initialInputsLog = "";
		if(this.initialDirections[0]) {
			initialInputsLog += " LEFT";
			this.sendGameInput(37,true);
		}
		if(this.initialDirections[1]) {
			initialInputsLog += " RIGHT";
			this.sendGameInput(39,true);
		}
		if(this.initialDirections[2]) {
			initialInputsLog += " UP";
			this.sendGameInput(38,true);
		}
		if(this.initialDirections[3]) {
			initialInputsLog += " DOWN";
			this.sendGameInput(40,true);
		}
		if(buffer && initialInputsLog != "") {
			console.log("---> Initial buttons: " + initialInputsLog);
		}
	}
	,resetLevel: function(slot,replay) {
		if(replay == null) {
			replay = false;
		}
		console.log("[" + (replay ? "REPLAY" : "RESET to") + " " + (slot == null ? "start" : "slot " + (slot == null ? "null" : "" + slot) + "...") + "] @ 1");
		this.sendGameInput(82,true);
		this.sendGameInput(82,false);
		if(slot == null) {
			this.recording = new VideoRecorder(this.initialDirections);
		}
		this.control = new PlayControl();
		this.primeControls(true);
	}
	,loadPlayback: function(video) {
		this.playback = haxe_ds_Option.Some(new VideoPlayer(video));
		this.initialDirections = video.initialDirections.slice();
		this.recording = new VideoRecorder(this.initialDirections);
	}
	,handleInterfaceInput: function(input,ctrlKey,altKey) {
		var oldControl = JSON.parse(JSON.stringify(this.control));
		if(input == CoffeeInput.StepFrame && this.control.paused) {
			this.triggerPausedCallback();
			console.log("[STEP  ] @ " + this.control.frame);
			return true;
		}
		if(input == CoffeeInput.Pause) {
			if(!oldControl.paused) {
				console.log("[PAUSE ] @ " + (this.control.frame + 1));
			}
			this.control.pause();
			return true;
		}
		var playAction = true;
		switch(input[1]) {
		case 2:
			this.control.speed = 0;
			break;
		case 3:
			this.control.speed = 1;
			break;
		case 4:
			this.control.speed = 2;
			break;
		default:
			playAction = false;
		}
		if(playAction) {
			this.control.paused = false;
			if(oldControl.paused) {
				console.log("[PLAY  ] @ " + this.control.frame);
			}
			this.triggerPausedCallback();
			return true;
		}
		if(input == CoffeeInput.Reset) {
			this.playback = haxe_ds_Option.None;
			this.resetLevel();
			this.control.pause();
			this.triggerPausedCallback();
			return true;
		}
		if(input == CoffeeInput.Replay) {
			this.resetLevel(0,true);
			this.loadPlayback(this.slots[0]);
			this.control.speed = 1;
			this.triggerPausedCallback();
			return true;
		}
		if(input[1] == 7) {
			var slot = input[2];
			if(!ctrlKey) {
				this.resetLevel(slot);
				this.loadPlayback(this.slots[slot]);
				this.control.speed = 2;
				this.control.silent = true;
				if(altKey) {
					this.control.pause();
					this.control.silent = false;
				}
				this.triggerPausedCallback();
				return true;
			}
			if(ctrlKey && !altKey) {
				this.control.pause();
				var video = this.recording.saveVideo(this.control.frame);
				console.log("[SAVE slot " + slot + "] @ " + this.control.frame);
				console.log("Data: " + video.toString());
				this.slots[slot] = video;
				return true;
			}
		}
		return false;
	}
	,onScene: function(levelNum) {
		if(levelNum == -1) {
			return;
		}
		console.log("[SCENE " + levelNum + "]");
		if(levelNum == 0) {
			return;
		}
		if(this.fullgameVideo != null && this.fullgameVideo.length >= levelNum) {
			this.fullgameLevelCounter = levelNum;
			this.loadPlayback(this.fullgameVideo[this.fullgameLevelCounter - 1]);
			this.control.paused = false;
			this.control.frame = 0;
			this.control.speed = 1;
			this.primeControls(false);
		}
	}
	,truncateFloat: function(number,digits) {
		var re = new EReg("(\\d+\\.\\d{" + digits + "})(\\d)","i");
		var isMatched = re.match(number == null ? "null" : "" + number);
		if(isMatched) {
			return parseFloat(re.matched(1));
		} else {
			return number;
		}
	}
};
var CoffeeInput = { __ename__ : true, __constructs__ : ["StepFrame","Pause","PlaySlow","PlayNormal","PlayFast","Replay","Reset","Slot"] };
CoffeeInput.StepFrame = ["StepFrame",0];
CoffeeInput.StepFrame.__enum__ = CoffeeInput;
CoffeeInput.Pause = ["Pause",1];
CoffeeInput.Pause.__enum__ = CoffeeInput;
CoffeeInput.PlaySlow = ["PlaySlow",2];
CoffeeInput.PlaySlow.__enum__ = CoffeeInput;
CoffeeInput.PlayNormal = ["PlayNormal",3];
CoffeeInput.PlayNormal.__enum__ = CoffeeInput;
CoffeeInput.PlayFast = ["PlayFast",4];
CoffeeInput.PlayFast.__enum__ = CoffeeInput;
CoffeeInput.Replay = ["Replay",5];
CoffeeInput.Replay.__enum__ = CoffeeInput;
CoffeeInput.Reset = ["Reset",6];
CoffeeInput.Reset.__enum__ = CoffeeInput;
CoffeeInput.Slot = function(code) { var $x = ["Slot",7,code]; $x.__enum__ = CoffeeInput; return $x; };
var KeyBindings = function() { };
KeyBindings.__name__ = true;
KeyBindings.fromKeyCode = function(code) {
	switch(code) {
	case 13:
		return haxe_ds_Option.Some(CoffeeInput.Replay);
	case 65:
		return haxe_ds_Option.Some(CoffeeInput.Pause);
	case 68:
		return haxe_ds_Option.Some(CoffeeInput.PlayNormal);
	case 70:
		return haxe_ds_Option.Some(CoffeeInput.PlayFast);
	case 82:
		return haxe_ds_Option.Some(CoffeeInput.Reset);
	case 83:
		return haxe_ds_Option.Some(CoffeeInput.PlaySlow);
	case 90:
		return haxe_ds_Option.Some(CoffeeInput.StepFrame);
	default:
		if(code >= 48 && code <= 57) {
			return haxe_ds_Option.Some(CoffeeInput.Slot(code - 48));
		} else {
			return haxe_ds_Option.None;
		}
	}
};
var KeyCodes = function() { };
KeyCodes.__name__ = true;
KeyCodes.toKey = function(keyCode) {
	switch(keyCode) {
	case 27:
		return "Escape";
	case 32:
		return " ";
	case 37:
		return "ArrowLeft";
	case 38:
		return "ArrowUp";
	case 39:
		return "ArrowRight";
	case 40:
		return "ArrowDown";
	case 65:
		return "a";
	case 66:
		return "b";
	case 67:
		return "c";
	case 68:
		return "d";
	case 69:
		return "e";
	case 70:
		return "f";
	case 71:
		return "g";
	case 72:
		return "h";
	case 73:
		return "i";
	case 74:
		return "j";
	case 75:
		return "k";
	case 76:
		return "l";
	case 77:
		return "m";
	case 78:
		return "n";
	case 79:
		return "o";
	case 80:
		return "p";
	case 81:
		return "q";
	case 82:
		return "r";
	case 83:
		return "s";
	case 84:
		return "t";
	case 85:
		return "u";
	case 86:
		return "v";
	case 87:
		return "w";
	case 88:
		return "x";
	case 89:
		return "y";
	case 90:
		return "z";
	default:
		return "";
	}
};
var Main = function() { };
Main.__name__ = true;
Main.infoTrace = function(str) {
	console.log("    " + str);
};
Main.main = function() {
	console.log("  _____           _              _      _____       __  __          \r\n |_   _|         | |            | |    / ____|     / _|/ _|         \r\n   | |  _ __  ___| |_ __ _ _ __ | |_  | |     ___ | |_| |_ ___  ___ \r\n   | | | '_ \\/ __| __/ _` | '_ \\| __| | |    / _ \\|  _|  _/ _ \\/ _ \\\r\n  _| |_| | | \\__ \\ || (_| | | | | |_  | |___| (_) | | | ||  __/  __/\r\n |_____|_| |_|___/\\__\\__,_|_| |_|\\__|  \\_____\\___/|_| |_| \\___|\\___|");
	console.log("Instant Coffee is enabled.");
	Main.infoTrace("[r] to reset and pause.");
	Main.infoTrace("[a-s-d-f] to adjust playback speed.");
	Main.infoTrace("[z] to step frame.");
	Main.infoTrace("[0-9] to reset and play back video in the respective slot (used for save states).");
	Main.infoTrace("Ctrl + [0-9] to save video in the respective slot.");
	Main.infoTrace("Alt + [0-9] to play back video in the respective slot, pausing on frame 1.");
	Main.infoTrace("[Enter] to reset and play the video in slot 0 in normal speed.");
	Main.infoTrace("`coffee.load(string)` to load a video into slot 0.");
	Main.infoTrace("`coffee.startLeft()` / `coffee.StartRight()` / `coffee.StartNeutral()` - configure the inputs on frame 0 of a level.");
	Main.infoTrace("`coffee.loadFullGame(array<string>)` to play a full game of several levels. Parameter is array of video codes.");
	Main.infoTrace("`coffee.clearFullGame()` to delete the current loaded full game video.");
	Main.infoTrace("`coffee.setFPS(number)` to change the FPS value. Parameter must be an integer. Default FPS is 60.");
	var engine = new Engine();
};
Math.__name__ = true;
var Util = function() { };
Util.__name__ = true;
Util.isSome = function(x) {
	switch(x[1]) {
	case 0:
		return true;
	case 1:
		return false;
	}
};
var Video = function(save) {
	this.initialDirections = [false,false,false,false];
	this.pauseFrame = 0;
	this.actions = [];
	if(save == null) {
		return;
	}
	var reader = new BSReader(save);
	this.initialDirections[0] = this.getOption(reader.readInt(1)) == 1;
	this.initialDirections[1] = this.getOption(reader.readInt(1)) == 1;
	this.initialDirections[2] = this.getOption(reader.readInt(1)) == 1;
	this.initialDirections[3] = this.getOption(reader.readInt(1)) == 1;
	this.pauseFrame = this.getOption(reader.readInt(Video.frameBitSize));
	var actionsLength = this.getOption(reader.readInt(12));
	var _g1 = 0;
	var _g = actionsLength;
	while(_g1 < _g) {
		var i = _g1++;
		var frame = this.getOption(reader.readInt(Video.frameBitSize));
		var code = this.getOption(reader.readInt(3));
		var pressed = this.getOption(reader.readInt(1));
		this.actions.push({ frame : frame, code : code, pressed : pressed == 1});
	}
};
Video.__name__ = true;
Video.toActionCode = function(keyCode) {
	var _g1 = 0;
	var _g = Video.keyCodes.length;
	while(_g1 < _g) {
		var i = _g1++;
		if(Video.keyCodes[i] == keyCode) {
			return haxe_ds_Option.Some(i);
		}
	}
	return haxe_ds_Option.None;
};
Video.fromActionCode = function(actionCode) {
	return Video.keyCodes[actionCode];
};
Video.showActionCode = function(actionCode) {
	switch(actionCode) {
	case 0:
		return "Left   ";
	case 1:case 4:
		return "Up     ";
	case 2:
		return "Right  ";
	case 3:
		return "Down   ";
	}
	return "???    ";
};
Video.prototype = {
	getOption: function(x) {
		switch(x[1]) {
		case 0:
			var x1 = x[2];
			return x1;
		case 1:
			throw new js__$Boot_HaxeError("Invalid video string.");
			break;
		}
	}
	,toString: function() {
		var writer = new BSWriter();
		writer.writeInt(this.initialDirections[0] ? 1 : 0,1);
		writer.writeInt(this.initialDirections[1] ? 1 : 0,1);
		writer.writeInt(this.initialDirections[2] ? 1 : 0,1);
		writer.writeInt(this.initialDirections[3] ? 1 : 0,1);
		writer.writeInt(this.pauseFrame,Video.frameBitSize);
		writer.writeInt(this.actions.length,12);
		var lastFrame = 0;
		var _g = 0;
		var _g1 = this.actions;
		while(_g < _g1.length) {
			var action = _g1[_g];
			++_g;
			writer.writeInt(action.frame,Video.frameBitSize);
			writer.writeInt(action.code,3);
			writer.writeInt(action.pressed ? 1 : 0,1);
		}
		return writer.toString();
	}
	,copy: function() {
		var video = new Video();
		video.actions = this.actions.slice();
		video.pauseFrame = this.pauseFrame;
		video.initialDirections = this.initialDirections.slice();
		return video;
	}
};
var VideoRecorder = function(initialDirections) {
	this.video = new Video();
	this.keyStates = [];
	var _g1 = 0;
	var _g = Video.keyCodes.length;
	while(_g1 < _g) {
		var i = _g1++;
		this.keyStates.push(false);
	}
	this.video.initialDirections = initialDirections;
};
VideoRecorder.__name__ = true;
VideoRecorder.prototype = {
	recordKey: function(frame,keyCode,pressed,silent) {
		var _g = Video.toActionCode(keyCode);
		switch(_g[1]) {
		case 0:
			var action = _g[2];
			var oldState = this.keyStates[action];
			if(pressed == oldState) {
				return;
			}
			this.keyStates[action] = pressed;
			if(frame > 0) {
				this.video.actions.push({ frame : frame, code : action, pressed : pressed});
			}
			if(!silent) {
				console.log("---> " + Video.showActionCode(action) + " " + (pressed ? "press  " : "unpress") + " @ " + frame);
			}
			break;
		case 1:
			return;
		}
	}
	,saveVideo: function(frame) {
		var res = this.video.copy();
		res.pauseFrame = frame;
		return res;
	}
};
var VideoPlayer = function(video) {
	this.video = video.copy();
};
VideoPlayer.__name__ = true;
VideoPlayer.prototype = {
	getActions: function(frame) {
		var res = [];
		while(this.video.actions.length > 0 && this.video.actions[0].frame == frame) {
			var action = this.video.actions.shift();
			res.push({ code : Video.fromActionCode(action.code), pressed : action.pressed});
		}
		return res;
	}
};
var haxe_crypto_Base64 = function() { };
haxe_crypto_Base64.__name__ = true;
var haxe_ds_Option = { __ename__ : true, __constructs__ : ["Some","None"] };
haxe_ds_Option.Some = function(v) { var $x = ["Some",0,v]; $x.__enum__ = haxe_ds_Option; return $x; };
haxe_ds_Option.None = ["None",1];
haxe_ds_Option.None.__enum__ = haxe_ds_Option;
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
String.__name__ = true;
Array.__name__ = true;
Video.frameBitSize = 12;
Video.keyCodes = [37,38,39,40,87];
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
Main.main();
})();
